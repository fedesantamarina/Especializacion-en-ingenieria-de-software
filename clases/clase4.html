<div class="clase-content">
    <h1>Clase 4: Diseño y Arquitectura de Software</h1>

    <div class="clase-meta">
        <div class="meta-item">
            <strong>Módulo:</strong> Fundamentos
        </div>
        <div class="meta-item">
            <strong>Duración:</strong> 4 horas
        </div>
        <div class="meta-item">
            <strong>Nivel:</strong> Avanzado
        </div>
    </div>

    <h2>1. Fundamentos del Diseño de Software</h2>

    <p>
        El diseño de software constituye el proceso técnico mediante el cual los requerimientos se transforman en una representación del software que puede implementarse. Mientras los requerimientos especifican qué debe hacer el sistema, el diseño especifica cómo el sistema logrará esos objetivos. El diseño abarca múltiples niveles de abstracción, desde la arquitectura de alto nivel que define componentes principales y sus interacciones, hasta el diseño detallado que especifica algoritmos, estructuras de datos y interfaces de clases individuales. La calidad del diseño impacta profundamente atributos críticos del software como mantenibilidad, escalabilidad, rendimiento, y confiabilidad.
    </p>

    <p>
        El diseño de software es inherentemente una actividad compleja que involucra tomar numerosas decisiones técnicas interrelacionadas. Raramente existe una única solución óptima: el diseñador debe navegar trade-offs entre objetivos conflictivos, como flexibilidad versus simplicidad, rendimiento versus mantenibilidad, o time-to-market versus robustez arquitectónica. Las decisiones de diseño tienen consecuencias duraderas: las estructuras arquitectónicas fundamentales, una vez establecidas, resultan costosas de modificar sustancialmente. Por ello, el diseño requiere combinar conocimiento técnico profundo, experiencia práctica, y pensamiento creativo para concebir soluciones que satisfagan múltiples criterios simultáneamente.
    </p>

    <div class="info-box">
        <p><strong>Definición clave:</strong> El diseño de software es el proceso de definir la arquitectura, componentes, interfaces y otras características de un sistema para satisfacer requerimientos especificados, balanceando múltiples atributos de calidad.</p>
    </div>

    <h3>1.1 Principios Fundamentales del Diseño</h3>

    <p>
        Ciertos principios fundamentales han emergido a través de décadas de experiencia en construcción de sistemas de software, proporcionando guías valiosas para decisiones de diseño. La abstracción permite gestionar complejidad ocultando detalles irrelevantes y enfocándose en aspectos esenciales. La modularidad divide el sistema en componentes cohesivos con interfaces bien definidas, facilitando comprensión, desarrollo paralelo, testing, y mantenimiento. El ocultamiento de información, principio articulado por David Parnas, prescribe que cada módulo oculte decisiones de diseño que probablemente cambiarán, exponiendo solo interfaces estables.
    </p>

    <p>
        La separación de concerns busca dividir el sistema según diferentes aspectos de funcionalidad, minimizando superposición y acoplamiento. Alta cohesión y bajo acoplamiento constituyen objetivos fundamentales: módulos deben tener responsabilidades estrechamente relacionadas (alta cohesión) y dependencias mínimas entre módulos (bajo acoplamiento). Estos principios clásicos mantienen vigencia y relevancia, fundamentando prácticas de diseño contemporáneas. El desafío práctico radica en aplicar estos principios de manera apropiada en contextos específicos, equilibrando pureza conceptual con pragmatismo ingenieril.
    </p>

    <div class="mermaid">
    graph TB
        A[Principios de Diseño de Software] --> B[Abstracción]
        A --> C[Modularidad]
        A --> D[Ocultamiento de Información]
        A --> E[Separación de Concerns]
        A --> F[Alta Cohesión]
        A --> G[Bajo Acoplamiento]

        B --> H[Gestión de Complejidad]
        C --> H
        D --> H
        E --> H
        F --> I[Mantenibilidad]
        G --> I

        H --> J[Software de Calidad]
        I --> J

        style A fill:#9b59b6
        style J fill:#2ecc71,stroke:#27ae60,stroke-width:3px
    </div>

    <h3>1.2 Niveles de Diseño</h3>

    <p>
        El diseño de software se estructura típicamente en niveles jerárquicos. El diseño arquitectónico (o arquitectura de software) define la estructura de más alto nivel del sistema, identificando componentes principales, sus responsabilidades, y patrones de interacción entre ellos. Las decisiones arquitectónicas tienen impacto amplio y resultan costosas de cambiar posteriormente, por lo que requieren consideración cuidadosa de múltiples factores incluyendo requerimientos funcionales y no funcionales, restricciones tecnológicas, y consideraciones de negocio.
    </p>

    <p>
        El diseño de alto nivel (high-level design) refina la arquitectura, detallando estructura de subsistemas y sus interfaces. El diseño detallado (detailed design) especifica algoritmos, estructuras de datos, y diseño de clases o módulos individuales. Esta jerarquía permite gestionar complejidad mediante niveles de abstracción sucesivos: en cada nivel se razona sobre conceptos apropiados a ese nivel sin quedar abrumado por detalles de niveles inferiores. Sin embargo, los niveles no son estrictamente secuenciales: el diseño es inherentemente iterativo, con feedback entre niveles a medida que se descubren insights.
    </p>

    <h2>2. Arquitectura de Software</h2>

    <p>
        La arquitectura de software ha emergido como una subdisciplina fundamental dentro de la Ingeniería de Software. La arquitectura de un sistema de software comprende sus estructuras fundamentales, incluyendo componentes de software, sus propiedades externamente visibles, y las relaciones entre ellos. Las decisiones arquitectónicas establecen las estrategias fundamentales para lograr atributos de calidad como rendimiento, escalabilidad, disponibilidad, seguridad, modificabilidad, y interoperabilidad. La arquitectura también facilita comunicación entre stakeholders y captura decisiones de diseño tempranas que conforman el desarrollo subsecuente.
    </p>

    <h3>2.1 Estilos y Patrones Arquitectónicos</h3>

    <p>
        Los estilos arquitectónicos representan soluciones probadas para problemas arquitectónicos recurrentes. Un estilo arquitectónico define un vocabulario de tipos de componentes y conectores, junto con restricciones sobre cómo pueden combinarse. Los estilos arquitectónicos principales incluyen arquitectura en capas, donde componentes se organizan en capas jerárquicas con dependencias unidireccionales hacia capas inferiores; cliente-servidor, que separa funcionalidad en procesos o sistemas independientes que colaboran mediante protocolos de comunicación; y arquitectura basada en componentes, que enfatiza composición de componentes reusables con interfaces bien definidas.
    </p>

    <p>
        El estilo pipes-and-filters estructura sistemas como secuencias de componentes de procesamiento (filtros) conectados por conductos (pipes) que transportan datos. Este estilo resulta apropiado para procesamiento de flujos de datos. La arquitectura basada en eventos emplea eventos como mecanismo primario de comunicación entre componentes desacoplados, facilitando escalabilidad y extensibilidad. Arquitecturas orientadas a servicios (SOA) y microservicios, evoluciones contemporáneas, estructuran sistemas como conjuntos de servicios independientes con interfaces bien definidas, optimizando para despliegue independiente, escalabilidad granular, y resilencia.
    </p>

    <div class="mermaid">
    graph TB
        subgraph "Arquitectura en Capas"
            P[Presentación]
            P --> L[Lógica de Negocio]
            L --> D[Acceso a Datos]
            D --> DB[(Base de Datos)]
        end

        subgraph "Microservicios"
            MS1[Servicio Usuarios]
            MS2[Servicio Pedidos]
            MS3[Servicio Pagos]
            MS4[Servicio Inventario]

            API[API Gateway]
            API --> MS1
            API --> MS2
            API --> MS3
            API --> MS4
        end

        style P fill:#3498db
        style L fill:#9b59b6
        style D fill:#e74c3c
        style API fill:#2ecc71
    </div>

    <h3>2.2 Arquitecturas Hexagonales y Clean Architecture</h3>

    <p>
        La arquitectura hexagonal (también conocida como ports and adapters), propuesta por Alistair Cockburn, busca aislar la lógica de negocio central de dependencias externas como interfaces de usuario, bases de datos, o servicios externos. La lógica de negocio se coloca en el núcleo y se comunica con el mundo exterior exclusivamente mediante interfaces (ports) implementadas por adaptadores. Esta separación facilita testing de la lógica de negocio de manera aislada, intercambio de tecnologías externas sin impactar el core, y evolución independiente de diferentes partes del sistema.
    </p>

    <p>
        Clean Architecture, popularizada por Robert Martin (Uncle Bob), propone principios similares organizados en capas concéntricas donde las dependencias apuntan hacia adentro: capas externas dependen de capas internas, nunca al revés. El núcleo contiene entidades de negocio, rodeadas por casos de uso que orquestan flujos de negocio, rodeadas por adaptadores de interfaces y frameworks. Esta inversión de dependencias, implementada mediante inyección de dependencias y principios SOLID, permite que el código de negocio permanezca independiente de frameworks, UI, bases de datos, y otros detalles de implementación.
    </p>

    <h3>2.3 Documentación Arquitectónica</h3>

    <p>
        La arquitectura de software debe documentarse para facilitar comunicación entre stakeholders, guiar desarrollo e implementación, soportar análisis de arquitectura, y servir como base para evolución del sistema. El modelo de vistas 4+1 de Philippe Kruchten organiza la descripción arquitectónica en vistas que abordan concerns de diferentes stakeholders: vista lógica (estructura de clases y objetos), vista de proceso (aspectos dinámicos y concurrencia), vista física (mapeo a hardware), vista de desarrollo (organización de módulos de software), y escenarios que ilustran arquitectura mediante casos de uso concretos.
    </p>

    <p>
        El estándar IEEE 1471 (posteriormente ISO/IEC/IEEE 42010) proporciona un framework para describir arquitecturas mediante viewpoints y views. Cada viewpoint define perspectiva desde la cual se observa el sistema, apropiada para concerns específicos y stakeholders particulares. El lenguaje de descripción arquitectónica Arc42 proporciona una plantilla estructurada que cubre contexto, restricciones, decisiones arquitectónicas clave, building blocks, conceptos transversales, decisiones de diseño, y riesgos técnicos. La documentación efectiva balancea exhaustividad con pragmatismo, documentando decisiones significativas sin abrumar con detalles triviales.
    </p>

    <h3>2.4 Evaluación y Análisis de Arquitecturas</h3>

    <p>
        Las arquitecturas pueden evaluarse mediante diversos métodos formales antes de comprometer recursos significativos a implementación. El método ATAM (Architecture Tradeoff Analysis Method), desarrollado por el SEI (Software Engineering Institute), proporciona un proceso estructurado para evaluar arquitecturas respecto a atributos de calidad, identificar trade-offs, y revelar riesgos arquitectónicos. ATAM involucra stakeholders diversos en workshops facilitados donde se analizan escenarios de atributos de calidad, se evalúa cómo la arquitectura soporta cada escenario, y se identifican puntos de sensibilidad y trade-offs.
    </p>

    <p>
        Otros métodos como SAAM (Software Architecture Analysis Method), enfocado en modificabilidad, o CBAM (Cost Benefit Analysis Method), que incorpora análisis económico, proporcionan alternativas para contextos específicos. El análisis arquitectónico cualitativo complementa prototipado y experimentación cuando aspectos críticos de rendimiento, escalabilidad o seguridad requieren validación temprana. La inversión en evaluación arquitectónica resulta modesta comparada con costos de rectificar arquitecturas fundamentalmente inadecuadas después de implementación sustancial.
    </p>

    <h2>3. Patrones de Diseño</h2>

    <p>
        Los patrones de diseño representan soluciones probadas a problemas recurrentes de diseño en contextos específicos. Popularizados por el libro seminal "Design Patterns: Elements of Reusable Object-Oriented Software" de Gamma, Helm, Johnson y Vlissides (la "Gang of Four" o GoF), los patrones de diseño han transformado la práctica del diseño orientado a objetos. Un patrón captura conocimiento de diseño de manera que pueda comunicarse, aprenderse y aplicarse efectivamente, proporcionando un vocabulario común para discutir soluciones de diseño.
    </p>

    <h3>3.1 Patrones Creacionales</h3>

    <p>
        Los patrones creacionales se enfocan en mecanismos de creación de objetos, incrementando flexibilidad y reuso. El patrón Singleton asegura que una clase tenga una única instancia y proporciona punto de acceso global, útil para gestionar recursos compartidos como conexiones de base de datos o configuración. Factory Method define una interfaz para crear objetos pero permite que subclases decidan qué clase instanciar, desacoplando código cliente de clases concretas. Abstract Factory proporciona interfaz para crear familias de objetos relacionados sin especificar sus clases concretas.
    </p>

    <p>
        El patrón Builder separa construcción de objetos complejos de su representación, permitiendo mismo proceso de construcción crear diferentes representaciones. Prototype especifica tipos de objetos a crear usando instancia prototípica y crea nuevos objetos clonando el prototipo. Estos patrones abordan problemas como dependencias rígidas en código cliente, dificultad para cambiar clases concretas usadas, o complejidad de construcción de objetos. Su aplicación apropiada mejora flexibilidad y mantenibilidad, aunque uso excesivo puede introducir complejidad innecesaria.
    </p>

    <div class="warning-box">
        <p><strong>Antipatrón común:</strong> Aplicar patrones de diseño indiscriminadamente sin necesidad real introduce complejidad innecesaria. Los patrones deben aplicarse cuando el problema que resuelven efectivamente existe, no como ejercicio académico.</p>
    </div>

    <h3>3.2 Patrones Estructurales</h3>

    <p>
        Los patrones estructurales se enfocan en composición de clases y objetos para formar estructuras mayores. El patrón Adapter convierte interfaz de una clase en otra interfaz esperada por clientes, permitiendo colaboración entre clases con interfaces incompatibles. Bridge desacopla abstracción de su implementación permitiendo que varíen independientemente. Composite permite tratar objetos individuales y composiciones de objetos uniformemente, útil para estructuras jerárquicas tipo árbol.
    </p>

    <p>
        Decorator añade responsabilidades a objetos dinámicamente, proporcionando alternativa flexible a herencia para extender funcionalidad. Facade proporciona interfaz unificada simplificada a conjunto de interfaces en subsistema, facilitando uso de subsistemas complejos. Proxy proporciona sustituto o placeholder para otro objeto, controlando acceso a él. Flyweight utiliza compartición para soportar eficientemente gran número de objetos de grano fino. Estos patrones abordan problemas de organización estructural, encapsulación de subsistemas, y gestión eficiente de objetos.
    </p>

    <h3>3.3 Patrones de Comportamiento</h3>

    <p>
        Los patrones de comportamiento se enfocan en algoritmos y asignación de responsabilidades entre objetos. Observer define dependencia uno-a-muchos entre objetos de modo que cuando un objeto cambia estado, todos sus dependientes son notificados y actualizados automáticamente. Strategy encapsula familia de algoritmos intercambiables, permitiendo que varíen independientemente de clientes que los usan. Command encapsula solicitud como objeto, permitiendo parametrizar clientes con diferentes solicitudes, encolar solicitudes, y soportar operaciones deshacer.
    </p>

    <p>
        State permite que un objeto altere su comportamiento cuando su estado interno cambia, aparentando cambiar su clase. Template Method define esqueleto de algoritmo en operación, diferiendo algunos pasos a subclases. Iterator proporciona manera de acceder elementos de objeto agregado secuencialmente sin exponer representación subyacente. Visitor representa operación a realizar sobre elementos de estructura de objetos, permitiendo definir nueva operación sin cambiar clases de elementos operados. Otros patrones comportamentales incluyen Chain of Responsibility, Mediator, Memento, e Interpreter, cada uno resolviendo problemas específicos de diseño comportamental.
    </p>

    <div class="mermaid">
    classDiagram
        class Subject {
            +attach(Observer)
            +detach(Observer)
            +notify()
        }
        class Observer {
            <<interface>>
            +update()
        }
        class ConcreteSubject {
            -state
            +getState()
            +setState()
        }
        class ConcreteObserver {
            -observerState
            +update()
        }

        Subject <|-- ConcreteSubject
        Observer <|-- ConcreteObserver
        Subject o-- Observer
        ConcreteObserver ..> ConcreteSubject : observes

        note for Observer "Patrón Observer:\nDefine dependencia 1-a-N\nentre objetos"
    </div>

    <h3>3.4 Patrones Empresariales</h3>

    <p>
        Martin Fowler identificó patrones específicos para aplicaciones empresariales en su obra "Patterns of Enterprise Application Architecture". Estos patrones abordan problemas característicos de sistemas empresariales como gestión de transacciones, acceso a datos, lógica de negocio compleja, y presentación. Patrones de acceso a datos incluyen Data Mapper (capa que transfiere datos entre objetos y base de datos manteniendo independencia), Active Record (objeto encapsula fila de base de datos y lógica de acceso a datos), y Repository (media entre capa de dominio y data mapping actuando como colección de objetos en memoria).
    </p>

    <p>
        Patrones de lógica de negocio incluyen Transaction Script (organiza lógica de negocio por procedimientos donde cada procedimiento maneja solicitud de presentación), Domain Model (modelo de objetos del dominio que incorpora comportamiento y datos), y Table Module (instancia única maneja lógica de negocio para todas las filas de tabla). Patrones de presentación incluyen Model-View-Controller, Model-View-Presenter, y Model-View-ViewModel, que separan lógica de presentación de lógica de negocio. La selección apropiada de patrones empresariales impacta significativamente mantenibilidad y testabilidad de aplicaciones empresariales.
    </p>

    <h2>4. Principios SOLID</h2>

    <p>
        Los principios SOLID, articulados por Robert Martin, representan cinco principios fundamentales de diseño orientado a objetos que promueven código mantenible, flexible y robusto. Estos principios han ganado aceptación amplia como guías fundamentales para diseño de calidad. SOLID constituye un acrónimo de Single Responsibility Principle, Open/Closed Principle, Liskov Substitution Principle, Interface Segregation Principle, y Dependency Inversion Principle.
    </p>

    <h3>4.1 Single Responsibility Principle (SRP)</h3>

    <p>
        El Principio de Responsabilidad Única establece que una clase debe tener una única razón para cambiar, es decir, debe tener una única responsabilidad. Cuando una clase asume múltiples responsabilidades, cambios en una responsabilidad pueden impactar o romper código relacionado con otras responsabilidades. SRP promueve alta cohesión: clases cuyos métodos y datos están estrechamente relacionados. Aplicar SRP resulta en clases más pequeñas, focalizadas, fáciles de comprender, testear y mantener. El desafío radica en identificar apropiadamente qué constituye una "responsabilidad única", lo cual requiere comprensión del dominio y anticipación de posibles vectores de cambio.
    </p>

    <h3>4.2 Open/Closed Principle (OCP)</h3>

    <p>
        El Principio Abierto/Cerrado establece que entidades de software deben estar abiertas para extensión pero cerradas para modificación. El objetivo es diseñar módulos que puedan extenderse con nuevo comportamiento sin modificar código existente, reduciendo riesgo de introducir defectos en funcionalidad ya probada. OCP típicamente se logra mediante abstracción: definir interfaces o clases abstractas estables y crear nuevas implementaciones para extender comportamiento. Patrones como Strategy y Template Method facilitan aplicación de OCP. Este principio resulta especialmente valioso en sistemas grandes donde modificaciones tienen alto riesgo y costo.
    </p>

    <h3>4.3 Liskov Substitution Principle (LSP)</h3>

    <p>
        El Principio de Sustitución de Liskov, formulado por Barbara Liskov, establece que objetos de una clase derivada deben poder reemplazar objetos de la clase base sin alterar corrección del programa. En términos más formales, los subtipos deben ser sustituibles por sus tipos base. Violaciones de LSP crean situaciones donde código cliente debe conocer tipos concretos y manejar casos especiales, erosionando beneficios del polimorfismo. LSP implica que clases derivadas deben honrar contratos establecidos por clases base: precondiciones no pueden fortalecerse, postcondiciones no pueden debilitarse, e invariantes deben preservarse.
    </p>

    <h3>4.4 Interface Segregation Principle (ISP)</h3>

    <p>
        El Principio de Segregación de Interfaces establece que clientes no deben forzarse a depender de interfaces que no usan. Interfaces grandes que proporcionan muchos métodos para diferentes tipos de clientes resultan problemáticas: cambios en interfaz por necesidades de un cliente impactan todos los clientes. ISP recomienda dividir interfaces grandes en interfaces más pequeñas y específicas que agrupan métodos relacionados. Clientes dependen solo de interfaces que realmente necesitan. Esto reduce acoplamiento, facilita comprensión, y limita impacto de cambios. ISP se relaciona con SRP aplicado a interfaces.
    </p>

    <h3>4.5 Dependency Inversion Principle (DIP)</h3>

    <p>
        El Principio de Inversión de Dependencias establece que módulos de alto nivel no deben depender de módulos de bajo nivel; ambos deben depender de abstracciones. Además, abstracciones no deben depender de detalles; detalles deben depender de abstracciones. Este principio invierte dependencias tradicionales donde capas superiores dependen de capas inferiores. En su lugar, se define interfaz abstracta basada en necesidades de cliente de alto nivel, y módulos de bajo nivel implementan esa interfaz. DIP, implementado típicamente mediante inyección de dependencias, facilita testing (mediante mocks), intercambio de implementaciones, y evolución independiente de capas.
    </p>

    <h2>5. Domain-Driven Design (DDD)</h2>

    <p>
        Domain-Driven Design, articulado por Eric Evans, proporciona enfoque para diseñar sistemas complejos centrándose en el modelo del dominio de negocio. DDD reconoce que para sistemas empresariales complejos, la complejidad central radica en el dominio de negocio, no en aspectos técnicos. El objetivo es desarrollar un modelo de dominio rico que capture conocimiento de negocio, expresando lógica de dominio de manera que refleje conceptos del negocio. Este modelo sirve como fundamento para diseño e implementación, y como lenguaje común (ubiquitous language) entre desarrolladores y expertos de dominio.
    </p>

    <h3>5.1 Building Blocks Tácticos de DDD</h3>

    <p>
        DDD define building blocks tácticos para implementar modelos de dominio. Entities son objetos con identidad que persiste en el tiempo. Value Objects son objetos inmutables sin identidad conceptual, definidos por sus atributos. Aggregates agrupan entities y value objects en unidades de consistencia con raíz de agregado como punto de acceso. Repositories proporcionan abstracción para acceso a aggregates, encapsulando lógica de persistencia. Domain Services encapsulan lógica de dominio que no pertenece naturalmente a entities o value objects. Domain Events capturan ocurrencias significativas en el dominio.
    </p>

    <h3>5.2 Patrones Estratégicos de DDD</h3>

    <p>
        Los patrones estratégicos de DDD abordan diseño a mayor escala. Bounded Contexts establecen límites explícitos dentro de los cuales un modelo particular es válido y consistente. Sistemas grandes típicamente contienen múltiples bounded contexts con modelos distintos. Context Maps documentan relaciones entre bounded contexts. Patrones de integración como Shared Kernel, Customer-Supplier, Conformist, o Anticorruption Layer describen diferentes maneras de relacionar contexts. Estos patrones estratégicos resultan cruciales para diseñar sistemas grandes manteniendo complejidad manejable.
    </p>

    <h2>6. Diseño para Atributos de Calidad</h2>

    <p>
        El diseño de software debe optimizar no solo para funcionalidad correcta sino también para atributos de calidad no funcionales. Diferentes atributos requieren estrategias de diseño específicas, frecuentemente en tensión entre sí. Diseñar para rendimiento puede involucrar caching, procesamiento asíncrono, o paralelización, pero puede comprometer simplicidad o consistencia. Diseñar para escalabilidad puede requerir arquitecturas distribuidas y stateless, introduciendo complejidad operacional. Diseñar para seguridad requiere aplicar principios como defensa en profundidad, privilegio mínimo, y fail-secure.
    </p>

    <p>
        El diseño para modificabilidad enfatiza modularidad, bajo acoplamiento, y localización de cambios probables. El diseño para testabilidad requiere dependencias inyectables, componentes pequeños con responsabilidades claras, y separación de lógica de negocio de infraestructura. El balance apropiado entre atributos de calidad depende del contexto: sistemas críticos priorizan confiabilidad y seguridad sobre otras consideraciones, mientras startups pueden priorizar velocidad de desarrollo sobre perfección arquitectónica. El diseño efectivo requiere comprender prioridades de atributos de calidad y aplicar tácticas apropiadas.
    </p>

    <div class="mermaid">
    graph TB
        A[Tácticas Arquitectónicas] --> B[Disponibilidad]
        A --> C[Rendimiento]
        A --> D[Seguridad]
        A --> E[Modificabilidad]
        A --> F[Testabilidad]

        B --> B1[Detección de Fallos]
        B --> B2[Recuperación]
        B --> B3[Prevención]

        C --> C1[Gestión de Recursos]
        C --> C2[Gestión de Demanda]
        C --> C3[Arbitración]

        D --> D1[Resistir Ataques]
        D --> D2[Detectar Ataques]
        D --> D3[Recuperación]

        E --> E1[Localizar Modificaciones]
        E --> E2[Prevenir Efecto Onda]
        E --> E3[Diferir Binding Time]

        F --> F1[Controlar Observabilidad]
        F --> F2[Controlar Controlabilidad]
        F --> F3[Limitar Complejidad]

        style A fill:#9b59b6
        style B fill:#2ecc71
        style C fill:#3498db
        style D fill:#e74c3c
    </div>

    <h2>7. Caso de Estudio: Rediseño Arquitectónico de Plataforma de E-Commerce</h2>

    <p>
        Este caso de estudio ilustra el proceso de evolucionar una arquitectura monolítica a microservicios, demostrando consideraciones de diseño arquitectónico, trade-offs, y patrones aplicados en contexto real.
    </p>

    <h3>7.1 Arquitectura Monolítica Original</h3>

    <p>
        La plataforma de e-commerce "ShopFast" operó exitosamente durante cinco años con arquitectura monolítica tradicional de tres capas: capa de presentación (aplicación web MVC), capa de lógica de negocio (servicios y reglas de negocio), y capa de acceso a datos (ORM sobre base de datos relacional PostgreSQL). El monolito contenía funcionalidad completa: gestión de catálogo de productos, carrito de compras, procesamiento de órdenes, gestión de inventario, facturación, CRM, y sistema de recomendaciones.
    </p>

    <p>
        Inicialmente, esta arquitectura proporcionó ventajas significativas: desarrollo rápido de nuevas características, debugging y testing simplificados en ambiente de desarrollo local, despliegue straightforward (single deployable unit), y transacciones ACID simples dentro del monolito. Sin embargo, a medida que el negocio escaló a millones de usuarios, el equipo de desarrollo creció a 50 ingenieros, y la base de código alcanzó cientos de miles de líneas, emergieron problemas críticos: despliegues riesgosos requiriendo downtime, escalabilidad limitada (todo el sistema debía escalar conjuntamente), tiempos de compilación y arranque prolongados, y coordinación compleja entre equipos trabajando en el mismo codebase.
    </p>

    <h3>7.2 Decisión de Migración a Microservicios</h3>

    <p>
        El análisis arquitectónico reveló que diferentes componentes del sistema tenían características radicalmente diferentes. El catálogo de productos experimentaba lecturas masivas pero escrituras ocasionales, apropiado para caching agresivo. El procesamiento de órdenes requería transacciones ACID estrictas y consistencia fuerte. El sistema de recomendaciones requería poder computacional significativo y podía tolerar consistencia eventual. El inventario requería actualizaciones frecuentes con concurrencia alta. Forzar todos estos componentes en arquitectura única con mismas características operacionales resultaba subóptimo.
    </p>

    <p>
        La decisión de migrar a microservicios fue impulsada por necesidad de: escalabilidad independiente de componentes según demanda, despliegue independiente permitiendo releases frecuentes sin riesgo global, aislamiento de fallos limitando impacto de problemas, autonomía de equipos cada uno responsable de servicios específicos, y flexibilidad tecnológica permitiendo seleccionar stacks óptimos para cada servicio. Sin embargo, se reconocieron trade-offs: incremento de complejidad operacional, desafíos de consistencia de datos distribuidos, latencia de comunicación inter-servicios, y overhead de gestión de servicios múltiples.
    </p>

    <h3>7.3 Diseño de Arquitectura de Microservicios</h3>

    <p>
        El sistema se descompuso en microservicios mediante Domain-Driven Design, identificando bounded contexts: Product Catalog Service, Inventory Service, Order Service, Payment Service, Customer Service, Recommendation Service, Notification Service, y Search Service. Cada servicio encapsula datos y lógica de negocio de su dominio, exponiendo APIs RESTful o gRPC. Los servicios se diseñaron para ser stateless cuando es posible, facilitando escalabilidad horizontal.
    </p>

    <p>
        La arquitectura incorporó patrones arquitectónicos específicos: API Gateway (usando Kong) como punto de entrada único manejando autenticación, rate limiting, y routing; Service Discovery (usando Consul) para registro y descubrimiento dinámico de instancias de servicios; Circuit Breaker (usando Hystrix) para prevenir cascading failures; Event-Driven Architecture (usando Kafka) para comunicación asíncrona y desacoplamiento; y CQRS para Order Service, separando modelos de lectura y escritura. Cada servicio mantiene su propia base de datos (polyglot persistence), con Product Catalog usando MongoDB, Order Service usando PostgreSQL, y Recommendation Service usando Cassandra.
    </p>

    <div class="mermaid">
    graph TB
        Client[Clientes Web/Mobile] --> Gateway[API Gateway]

        Gateway --> Auth[Auth Service]
        Gateway --> Catalog[Catalog Service]
        Gateway --> Order[Order Service]
        Gateway --> Search[Search Service]

        Order --> Payment[Payment Service]
        Order --> Inventory[Inventory Service]
        Order --> Notification[Notification Service]

        Catalog --> CatalogDB[(MongoDB)]
        Order --> OrderDB[(PostgreSQL)]
        Inventory --> InventoryDB[(Redis)]

        Order -.->|Eventos| Kafka[Kafka Event Bus]
        Notification -.->|Consume| Kafka
        Recommendation[Recommendation Service] -.->|Consume| Kafka

        ServiceDiscovery[Service Discovery] -.->|Registro| Catalog
        ServiceDiscovery -.->|Registro| Order
        ServiceDiscovery -.->|Registro| Payment

        style Gateway fill:#e74c3c
        style Kafka fill:#9b59b6
        style ServiceDiscovery fill:#3498db
    </div>

    <h3>7.4 Estrategia de Migración Incremental</h3>

    <p>
        La migración se ejecutó incrementalmente mediante patrón Strangler Fig: nuevas funcionalidades se implementaron como microservicios, mientras funcionalidad existente se extraía gradualmente del monolito. El API Gateway ruteaba solicitudes a microservicios cuando disponibles, cayendo back al monolito para funcionalidad aún no migrada. Este enfoque minimizó riesgo permitiendo validación de arquitectura nueva progresivamente. La migración completa requirió 18 meses, pero beneficios comenzaron a materializarse después de los primeros servicios críticos fueron extraídos.
    </p>

    <h2>8. Refactoring y Technical Debt</h2>

    <h3>8.1 Naturaleza del Technical Debt</h3>

    <p>
        El concepto de technical debt, introducido por Ward Cunningham, usa la metáfora de deuda financiera para describir consecuencias de decisiones de diseño subóptimas. Así como deuda financiera permite lograr objetivos inmediatos a costa de pagos de interés futuros, technical debt permite velocidad de desarrollo inmediata a costa de mantenibilidad reducida y velocidad disminuida futuras. El technical debt puede ser deliberado (decisión consciente de tomar atajo con plan de remediar después) o inadvertido (resultado de conocimiento insuficiente o diseño pobre).
    </p>

    <p>
        El technical debt se manifiesta de múltiples formas: código duplicado, clases con responsabilidades poco claras o múltiples, acoplamiento excesivo entre módulos, falta de tests automatizados, documentación inexistente o desactualizada, dependencias obsoletas, o arquitectura que no alinea con necesidades actuales. Los "pagos de interés" incluyen desarrollo lento de nuevas características, bugs frecuentes, dificultad para onboarding de nuevos desarrolladores, y esfuerzo significativo para cambios que deberían ser simples. Si no se gestiona, el technical debt puede acumularse hasta hacer el sistema prácticamente inmutable.
    </p>

    <h3>8.2 Estrategias de Refactoring</h3>

    <p>
        El refactoring consiste en reestructurar código existente sin cambiar su comportamiento externo, mejorando estructura interna. Martin Fowler catalogó refactorings específicos: Extract Method (extraer código duplicado a método separado), Rename (mejorar nombres para claridad), Extract Class (dividir clase con múltiples responsabilidades), Move Method (mover método a clase más apropiada), Replace Conditional with Polymorphism (reemplazar lógica condicional compleja con polimorfismo), entre docenas de otros. El refactoring debe ejecutarse en pasos pequeños, verificables, con tests automatizados proporcionando red de seguridad.
    </p>

    <p>
        Las estrategias para gestionar technical debt incluyen: asignar porcentaje de tiempo de desarrollo a pagar debt (por ejemplo, 20% de cada sprint), refactorizar oportunísticamente cuando se trabaja en código (dejar código mejor que como se encontró), programar sprints dedicados a pagar debt acumulado, o aplicar Boy Scout Rule (siempre dejar codebase ligeramente mejor que como se encontró). La clave consiste en balancear delivery de features con mantenimiento de health del codebase. Ignorar technical debt eventualmente paraliza desarrollo; obsesionarse con perfección impide entregar valor. El balance requiere juicio ingenieril maduro.
    </p>

    <h2>9. Ejercicios Prácticos</h2>

    <h3>9.1 Ejercicio de Diseño Arquitectónico</h3>

    <p>
        <strong>Escenario:</strong> Diseñe arquitectura de alto nivel para plataforma de streaming de video similar a Netflix, que debe soportar: 100 millones de usuarios globales, catálogo de 50,000 películas y series, streaming de video en múltiples calidades adaptativas, recomendaciones personalizadas, búsqueda de contenido, perfiles de usuario múltiples, y descarga para visualización offline.
    </p>

    <p>
        <strong>Tarea:</strong> (1) Identifique componentes arquitectónicos principales y sus responsabilidades; (2) Seleccione estilo arquitectónico apropiado, justificando elección; (3) Diseñe estrategias para atributos de calidad críticos: escalabilidad global, disponibilidad alta (99.99%), latencia baja para inicio de streaming, y personalización; (4) Proponga tecnologías específicas para componentes clave; (5) Documente decisiones arquitectónicas significativas usando Architecture Decision Records (ADRs); (6) Identifique riesgos arquitectónicos y estrategias de mitigación.
    </p>

    <h3>9.2 Ejercicio de Aplicación de Patrones</h3>

    <p>
        <strong>Tarea:</strong> Para cada escenario, identifique patrón(es) de diseño apropiado(s), justifique su selección, y dibuje diagrama de clases UML mostrando aplicación del patrón: (1) Sistema debe soportar múltiples formatos de exportación (PDF, Excel, CSV, XML) con posibilidad de agregar formatos nuevos frecuentemente; (2) Sistema de logging debe permitir enviar logs a múltiples destinos simultáneamente (archivo, base de datos, servicio remoto); (3) Operaciones costosas de construcción de objetos complejos con múltiples configuraciones opcionales; (4) Necesidad de deshacer/rehacer operaciones de usuario en aplicación de edición; (5) Gestión de diferentes estados de orden de compra (Pendiente, Pagado, Enviado, Entregado, Cancelado) con transiciones y comportamientos específicos.
    </p>

    <h3>9.3 Ejercicio de Evaluación de Trade-offs</h3>

    <p>
        <strong>Escenario:</strong> Un sistema de banca online debe procesar transacciones financieras. Dos arquitecturas se proponen: (A) Arquitectura monolítica con base de datos relacional única, garantizando transacciones ACID fuertes; (B) Arquitectura de microservicios con bases de datos distribuidas, usando eventual consistency y saga pattern para transacciones distribuidas.
    </p>

    <p>
        <strong>Tarea:</strong> (1) Analice cada arquitectura respecto a atributos de calidad: consistencia, disponibilidad, escalabilidad, complejidad operacional, latencia, y seguridad; (2) Identifique trade-offs específicos entre las arquitecturas; (3) Para cada arquitectura, describa escenarios donde falla o tiene dificultades; (4) Proponga arquitectura híbrida que combine fortalezas de ambas aproximaciones; (5) Haga recomendación justificada considerando contexto de banca online donde consistencia de datos financieros es crítica.
    </p>

    <div class="highlight-box">
        <h3>Resumen de la Clase</h3>
        <p>
            Esta clase ha proporcionado una visión integral del diseño y arquitectura de software, cubriendo principios fundamentales, estilos y patrones arquitectónicos, patrones de diseño clásicos y empresariales, principios SOLID, Domain-Driven Design, y diseño para atributos de calidad. El diseño y la arquitectura representan competencias centrales para especialistas en Ingeniería de Software, requiriendo dominio tanto de conocimientos teóricos como experiencia práctica para tomar decisiones de diseño efectivas que balanceen múltiples concerns.
        </p>
    </div>

    <div class="nav-buttons">
        <a href="#" class="btn btn-prev" data-clase="clase3">← Anterior: Ingeniería de Requerimientos</a>
        <a href="#" class="btn btn-next" data-clase="clase5">Siguiente: Bases de Datos Avanzadas →</a>
    </div>
</div>
